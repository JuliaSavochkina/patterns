'''
Singletone или одиночка.
Условия для применимости:
    - должен существовать ровно один экземпляр некоторого класса, к которому может обратиться любой клиент через
    известную точку доступа;
    - единственный экземпляр должен расширяться путем порождения подклассов, а клиенты должны иметь возможность
    работать с расширенным экземпляром без модификации своего кода.

Достоинства:
    - контролируемый доступ к единственному экземпляру;
    - сокращение пространства имен;
    - возможность уточнения операций и представлений;
    - возможность использования переменного числа экземпляров;
    - большая гибкость, чем у операций класса.
'''


class Singleton:
    '''
    В этом фрагменте кода мы переопределяем метод __new__ (специальный метод Python для создания объектов),
    что бы управлять созданием объекта. Объект s создается с помощью метода __new__, но перед этим он проверяет,
    существует ли уже созданный объект. Метод hasattr (специальный метод Python, позволяющий определить,
    имеет ли объект определенное свойство), используется для проверки наличия у объекта cls свойства instance.
    При создание объекта s, объект просто создается. В случае создания объекта s1, hasattr() обнаруживает,
    что у объекта уже существует свойство instance, и, следовательно, s1 использует уже существующий экземпляр объекта.
    '''
    def __new__(cls):
        if not hasattr(cls, 'instance'):
            cls.instance = super(Singleton, cls).__new__(cls)
        return cls.instance

s = Singleton()
print("Object created", s)  # Object created <__main__.Singleton object at 0x7f58ca473370>
s1 = Singleton()
print("Object created", s1)  # Object created <__main__.Singleton object at 0x7f58ca473370>

# ==============================================


class Singleton:
    '''
    В следующем примере кода, когда мы используем s = Singleton(), вызывается метод __init__,
    но при этом новый объект не будет создан. Фактическое создание объекта произойдет,
    когда мы используем Singleton.getInstance().
    '''
    __instance = None
    def __init__(self):
        if not Singleton.__instance:
            print(" __init__ method called..")
        else:
            print("Instance already created:", self.getInstance())
    @classmethod
    def getInstance(cls):
        if not cls.__instance:
            cls.__instance = Singleton()
        return cls.__instance

s = Singleton() ## class initialized, but object not created
print("Object created", Singleton.getInstance()) # Object gets created here
s1 = Singleton() ## instance already created


"""
Singleton на уровне модуля
Все модули по умолчанию являются синглетонами из-за особенностей работы импорта в Python.
Python работает следующим образом:
    - Проверяет, был ли уже импортирован модуль.
    - При импорте возвращает объект модуля. Если объекта не существует, то есть модуль не импортирован,
    он импортируется и создается его экземпляр.
    - Когда модуль импортируется, он инициализируется. Но когда тот же модуль импортируется снова,он уже не
    инициализируется, что похоже на поведение Singleton, имеющим только один объект и возвращающим один и тот же объект.
"""